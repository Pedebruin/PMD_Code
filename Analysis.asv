%{
This script serves as analysis for the wafer positioning system of PMD. 
Authors:

Thami Fischer
Mansour Khaleqi
Olivia Taal
Jos Boetzkes
Pim de Bruin

The script is set up in three main sections:
%% Settings
    Here, some settings for the script are determined. Mainly about the
    output of the script

%% Initialisation
    Here, the objects are made. The objects are all instances of the class
    'body'. They are also given their properties here. 

%% Analysis
    Here, the actual analysis is performed. This is done in a main loop
    which iterates from T0 to T1. 

The script is dependant on 
body.m              % Class defenition
plotMaterials.m     % Separate plot function for materials plot

All material models:
    Material models available:
    @alphaSilicon           - Nonlinear silicon model
    @alphaSilicon_Linear    - Linear silicon model
    @alphaCopper            - Nonlinear copper model
    @alphaCoppper_Linear    - Linear Copper model
    @alphaZero              - Zero expansion coefficient (for testing mostly)
%}
clear;
close all;
set(0,'defaultTextInterpreter','latex');                                    % Make everything look nice 
addpath('./materialModels');                                                % Add material model folder

%% Settings
    userSettings.animate = true;                % Animate the cooldown?
        userSettings.T0 = 273.15;               % [K] From staring temperature
        userSettings.T1 = 0.0015;               % [K] To ending tempeature
        userSettings.N = 100;                   % Amount of steps from T0 to T1
        userSettings.maxIter = 1000;           % Maximum amount of loops to solve for d
        userSettings.contactTol = 1e-14;        % mm to assume contact. 
    userSettings.Amplification = 50;            % Amplifies the schrink with a factor A for all bodies.
    userSettings.PlotMaterials = false;         % Show separate material model plot?
    userSettings.PlotContact = true;            % Move the wafer with the contact pins?
    userSettings.PlotTC = false;                 % Show the thermal center of the bodies?
    userSettings.PlotNames = true;              % Show the names of the bodies?
    userSettings.pauseStart = false;            % Pause before the start of the simulation
    userSettings.debug = false;                 % Debug mode? 
    
%% Initialisation (Creating the objects)
% Wafer 
    name = 'Wafer';
    waferRadius = 300;                                                      % mm
    material = 'Silicon';
    alpha_L = @alphaSilicon;                                                % Thermal expansion model   
    color = 'k';                                                            % Plot color
    position = [0,0]';                                                      % Initial position

    % Create wafer object 
    flatAngle = 20;                                                         % Angle of the flat on the wafer
    angles = linspace(-(180-flatAngle), 180-flatAngle, 100);                 % Array of angles
    Pos = waferRadius*[cosd(angles); sind(angles)];                         % Array of points to patch

    wafer = body(name, Pos, position, alpha_L, material, waferRadius, 'k', userSettings);     % Actual wafer object
    addprop(wafer,'flatAngle');
    wafer.flatAngle = flatAngle;
% Support pins
    material = 'Copper';
    alpha_L = @alphaCopper;
    pinRadius = 40;                                                         % mm
    pin1Angle = 45;                                                         % Angle of pin 1 w.r.t. pos x axis
    d_pins = 150;                                                           % Distance between pin 2&3
    
    % Pin locations
    pos_pin1 = [cosd(pin1Angle), -sind(pin1Angle);
                sind(pin1Angle), cosd(pin1Angle)]*[waferRadius+pinRadius,0]';
    pos_pin2 = [-waferRadius*cosd(flatAngle)-pinRadius,d_pins/2]';
    pos_pin3 = [-waferRadius*cosd(flatAngle)-pinRadius,-d_pins/2]';
    
    % Pin shape
    angles = linspace(0,359,100);                                            % Array of angles
    Pos_pin = pinRadius*[cosd(angles); sind(angles)];                       % Array of points to patch
    
    % Create three pins
    pin1 = body('pin1', Pos_pin, pos_pin1, alpha_L, material, pinRadius, 'c', userSettings);    
    pin2 = body('pin2', Pos_pin, pos_pin2, alpha_L, material, pinRadius, 'c', userSettings);
    pin3 = body('pin3', Pos_pin, pos_pin3, alpha_L, material, pinRadius, 'c', userSettings);
    
    bodies = {wafer, pin1, pin2, pin3};                                     % Package bodies it for easy looping
    
    
%% Termal cooldown analysis
% Thermal expansion coefficients plot? 
    if userSettings.PlotMaterials == true
        plotMaterials();
    end 

    
    % wafer.move([0.5,-0.5]',0)
    % Placement error^
    
% Make nice analysis plot
    figure('Name',['Kinematic Coupling ',num2str(userSettings.Amplification),'X'])
    hold on
    axis equal
    grid on
    title(['Thermal cooldown analysis ',num2str(userSettings.Amplification),'X'])
    xlabel('[mm]')
    ylabel('[mm]')
    xlim([-waferRadius, waferRadius]*1.3);
    ylim([-waferRadius, waferRadius]*1.3);
    
    if userSettings.animate == true
        N = userSettings.N;
    else
        N = 1;
    end
    
    T_v = linspace(userSettings.T0, userSettings.T1, N+1);
    Plots = [];
    for T = T_v
        % Cool down       
        for i = 1:size(bodies,2)
            bodies{i}.cool(T);
        end

        % Model contact kinematically!
        if userSettings.PlotContact == true
            % Initialisations & Preliminaries
            Iter = 0;
            contact1 = false;
            contact23 = false;
            pin1.color = 'c';
            pin2.color = 'c';
            pin3.color = 'c';
            contactTol = userSettings.contactTol;
            
            % Look for direction to move the wafer
            while contact1 || contact23 || Iter == 0                        % While there is still contact somewhere
                
                % Detect contact 1 and find direction
                [separation1, d1] = sep1(wafer,pin1);                       % Homecooked function
                if separation1 < -contactTol                    % Overlap! 
                    pin1.color = 'r';
                    contact1 = true;
                else                                                        % No overlap
                    d1 = [0,0]';
                    contact1 = false;
                end

                % Detect contact 2 & 3 and find direction
                [separation23,d23] = sep23(wafer,pin2);                     % Homecooked function
                if separation23 < -contactTol                   % Overlap!
                    pin2.color = 'r';
                    pin3.color = 'r';
                    contact23 = true;
                else % No overlap
                    d23 = [0,0]';
                    contact23 = false;           
                end
                
                d = (d1+d23)/norm(d1+d23);                              % Direction to move in
                if isnan(d)
                    d = [0,0]';
                end 

                % Do bisectoion for 
                if norm(d1) ~= 0                                             % If there's overlap somewhere!
                    h = norm(d);                                            % Initial step size
                    dir = 1;                                                % Initial step direction
 
                    IterBisection = 0;
                    oldSeparation1 = 0;
                    oldSeparation23 = 0;
                    
                    % Bisection loop
                    while abs(separation1) >= contactTol && abs(separation23) >= contactTol 
                        % Take a step
                        step = dir*d*h;
                        
                        wafer.move(step,0);
                        wafer.TC = wafer.TC + step;
                        
                        % New separations
                        [separation1,~] = sep1(wafer,pin1);
                        [separation23,~] = sep23(wafer,pin2);
                        
                        % Switch directions when a contact is overshot,
                        % also half the step size. 
                        currSep = separation1*separation23;
                        oldSep = oldSeparation1*oldSeparation23;
                        if sign(oldSeparation1) ~= sign(separation1) && oldSep ~= 0       % If overshoot
                            dir = -dir;
                            h = h/2;
                        end
                        
                        % Old separations
                        oldSeparation1 = separation1;
                        oldSeparation23 = separation23;
                        
                        % Housekeeping
                        IterBisection = IterBisection+1;
                        disp('Looooping')
                        
                        if IterBisection >= userSettings.maxIter                             % Safeguard for infinite loop
                            warnmsg = ['No good wafer move found after ',num2str(IterBisection-1),' iterations!'];
                            warning(warnmsg)
                            break
                        end
                    end 
                    disp(['Move found after ',num2str(IterBisection),' bisection iterations!'])      % If while is broken!  
                end                                
                
                Iter = Iter+1;                                              % Update iteration variable
            end
            disp(['Move found after ',num2str(Iter-1),' tries!'])      % If while is broken!
        end
            
        
        % Kill old bodies
        if userSettings.animate == true 
            pause(0.01);
            delete(Plots);
        end

        % Make new bodies
            for i = 1:size(bodies,2)
                Plots = [Plots, bodies{i}.show(gca)];
            end      

        % Update text
        str1 = {['T = ',num2str(round(T,2)),' K']...
            ['sep1 = ',num2str(separation1),' mm'],...
            ['sep23 = ',num2str(separation23),' mm']};
        Text1 = text(gca, -400,350,str1);
        Plots = [Plots,Text1];

        str2 = {'Wafer.pos:',...
                ['x = ',num2str(wafer.pos(1)),' mm'],...
                ['y = ',num2str(wafer.pos(2)),' mm']};
        Text2 = text(gca, 100, 350,str2);
        Plots = [Plots,Text2];

        % Housekeeping
        if userSettings.pauseStart == true && userSettings.animate == true
            if T == T_v(1)
                disp('Press any key to continue!')
                pause;
            end
        end
    end
    
        
%% Function defenitions
    function ang = angDiff(u,v)
        if size(u,1) == 2 && size(v,1)== 2
            u = [u; 0];
            v = [v; 0];
        end
        ang = rad2deg(atan2(norm(cross(u,v)),dot(u,v)));
    end

    function [separation1, d1] = sep1(wafer, pin1)
    %{
        This function checks the separation of pin1 and the wafer and
        returns the amount of separation, and the direcion in which the
        separation occurs. 
    %}
        currDist1 = pin1.pos - wafer.pos;                                   % Current distance between centers
        contactDist1 = (wafer.R+pin1.R)*currDist1/norm(currDist1);          % Distance between centes for contact
        separation1 = norm(currDist1)-norm(contactDist1);
        d1 = currDist1 - contactDist1;
    end

    function[separation23, d23] = sep23(wafer,pin2)
    %{
        This function checks the separation of pin2 and the wafer and
        returns the amount of separation, and the direcion in which the
        separation occurs.
    %}

        currDist23 = abs(pin2.pos(1) - wafer.pos(1));                       % Current distance between centers
        contactDist23 = wafer.R*cosd(wafer.flatAngle)+pin2.R;                     % Distance between centers for contact
        separation23 = currDist23-contactDist23;
        d23 = contactDist23 - norm(currDist23);                             % Assume 2&3 can only push in X direction. 
        d23 = [d23,0]'; 
    end